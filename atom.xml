<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-23T07:43:19.861Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day 5</title>
    <link href="http://example.com/2023/02/23/day-5/"/>
    <id>http://example.com/2023/02/23/day-5/</id>
    <published>2023-02-23T01:30:22.000Z</published>
    <updated>2023-02-23T07:43:19.861Z</updated>
    
    <content type="html"><![CDATA[<p>1.内存一共有几个区？<br>答：四个：代码区与全局区在程序运行之前就存在，栈区与堆区在程序运行后生成。</p><p>2.static与const修饰的区别？<br>答：static修饰的是静态变量放在全局区，而const修饰的是常量（其他常量），二者都在全局区。但是静态变量也是变量，也是可变的，只不过不随函数的开始和结束而创建和消亡。</p><p>3.如何利用new？<br>答：创建变量 int *p &#x3D;new int(10); delete p;     &#x2F;&#x2F;使用（）表示创建变量且值为10。<br>   ：创建数组 int *arr &#x3D;new int[10]; delete[] arr;  &#x2F;&#x2F;使用[]表示创建长度位10的数组。</p><p>4.引用的本质？<br>答：引用：int &amp;b &#x3D;a;给a取别名b，操作b等于操作a。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.内存一共有几个区？&lt;br&gt;答：四个：代码区与全局区在程序运行之前就存在，栈区与堆区在程序运行后生成。&lt;/p&gt;
&lt;p&gt;2.static与const修饰的区别？&lt;br&gt;答：static修饰的是静态变量放在全局区，而const修饰的是常量（其他常量），二者都在全局区。但是静态</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>dat 4</title>
    <link href="http://example.com/2023/02/22/dat-4/"/>
    <id>http://example.com/2023/02/22/dat-4/</id>
    <published>2023-02-22T01:39:06.000Z</published>
    <updated>2023-02-22T06:36:24.948Z</updated>
    
    <content type="html"><![CDATA[<p>1.Linux下的清屏操作？<br>答：system(“reset”); 需要包含头文件<stdlib></p><p>2.如何比较字符串？（char<em>）<br>答：用函数int  strcmp(const char</em> s1,const char * s2),字符串相等返回0，否则大于返回1，小于返回-1，需要包含头文件<string></p><p>3.如何比较字符串？（string）<br>答：string是c++中的类型，可以直接使用&#x3D;&#x3D;进行比较！！！</p><p>4.swicth语句中，若case代码过长，需要加{}。</p><p>5.在Linux中如果自定义函数名为黄色说明与库中函数重名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.Linux下的清屏操作？&lt;br&gt;答：system(“reset”); 需要包含头文件&lt;stdlib&gt;&lt;/p&gt;
&lt;p&gt;2.如何比较字符串？（char&lt;em&gt;）&lt;br&gt;答：用函数int  strcmp(const char&lt;/em&gt; s1,const char * s2),</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>day 3</title>
    <link href="http://example.com/2023/02/15/day-3/"/>
    <id>http://example.com/2023/02/15/day-3/</id>
    <published>2023-02-15T05:04:51.000Z</published>
    <updated>2023-02-21T02:48:25.499Z</updated>
    
    <content type="html"><![CDATA[<p>1.const与static的区别？<br>答：const定义的常量在超出作用域后会释放，而static定义的常量不会在函数运行完后被释放。</p><p>2.如何生成随机数？<br>答：int random &#x3D;rand（）%100 ； 这样会生成0-99的假随机数。</p><p>3.如何生成真随机数？<br>答：还是使用上面的语句，但是在main函数里加srand((unsigned int)time(NULL))；并包含<ctime>的头文件。</p><p>4.为什么用string定义的字符串cout时出警告？<br>答：因为没有包含头文件<string></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.const与static的区别？&lt;br&gt;答：const定义的常量在超出作用域后会释放，而static定义的常量不会在函数运行完后被释放。&lt;/p&gt;
&lt;p&gt;2.如何生成随机数？&lt;br&gt;答：int random &amp;#x3D;rand（）%100 ； 这样会生成0-99的假随机</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>day 2</title>
    <link href="http://example.com/2023/02/10/day-2/"/>
    <id>http://example.com/2023/02/10/day-2/</id>
    <published>2023-02-10T06:14:23.000Z</published>
    <updated>2023-02-10T08:54:15.878Z</updated>
    
    <content type="html"><![CDATA[<p>今天把前几天零零碎碎的知识点整理一下</p><ol><li><p>fopen函数返回一个FILE*结构体指针，那么该指针指向什么区域？<br>答：存放在堆区。<br>因为结构体中的变量是局部变量存放在栈中，那么当函数调用结束返回时，那个指针指向的空间已经被释放，所以不是栈。<br>也不能是静态区，因为用static修饰的时候，一个变量只会被声明一次，那么在整个函数中你只能调用一次fopen，否则打开第二个文件第一个就会失效。<br>因为堆内的空间又malloc申请，由free释放所以是最佳选择。<br>小窍门：如果返回指针的函数有互逆操作（fclose与fopen），那么返回指针大概率指向堆区。</p></li><li><p>int * p&#x3D;(int * )mallloc(sizeof(int))<br>这种强制类型转换不是在解决问题，为实在掩盖问题。不强转报错的原因是没有引用&lt;stdlib.h&gt;的头文件。</p></li><li><p>linux中查看errno含义的路径<br>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p></li></ol><p>4.一共有三种类型的报错方式<br>打印errno&#x3D;%d;  perror(“某函数”)； 打印sterror(errno);</p><p>5.const修饰指针<br>const int * p &#x3D;&amp;a ：const修饰* p ，* p不可变（内容不可变）<br>int * const p &#x3D;&amp;a ：const修饰p，p不可变（p中地址不可变）</p><p>6.指针变量与变量指针<br>指针变量是个变量<br>变量指针是个指针，指针就是内存地址<br>p&#x3D;&amp;a ； 左边是指针变量，右边是指针</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天把前几天零零碎碎的知识点整理一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;fopen函数返回一个FILE*结构体指针，那么该指针指向什么区域？&lt;br&gt;答：存放在堆区。&lt;br&gt;因为结构体中的变量是局部变量存放在栈中，那么当函数调用结束返回时，那个指针指向的空间已经被释放，所以不是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="http://example.com/2023/02/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2023/02/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2023-02-09T10:18:23.000Z</published>
    <updated>2023-02-09T12:59:09.276Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习了使用node，git与hexo，整理了今后一定会用到的四个指令：<br>1.hexo c 清理<br>2.hexo g 生成<br>3.hexo s 演示 （按住ctrl+左键可直接跳转到网址）<br>4.hexo d 部署到github<br>修改主题和上传博客都在这四个指令之前。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天学习了使用node，git与hexo，整理了今后一定会用到的四个指令：&lt;br&gt;1.hexo c 清理&lt;br&gt;2.hexo g 生成&lt;br&gt;3.hexo s 演示 （按住ctrl+左键可直接跳转到网址）&lt;br&gt;4.hexo d 部署到github&lt;br&gt;修改主题和上传博客</summary>
      
    
    
    
    
  </entry>
  
</feed>
