<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Zhaogy233</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">Zhaogy233</a></div><div class="about-me">Hi~</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/Zhaogy233"></span><a href="https://github.com/Zhaogy233" target="_blank" title="https://github.com/Zhaogy233">https://github.com/Zhaogy233</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="3468482206@qq.com"></span><span>3468482206@qq.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="z15566143013"></span><span>z15566143013</span></li></ul></div></div></div></header><div class="container home"><section class="article"><a class="title" href="/2023/02/28/Linux-1/">Linux 1</a><div class="content excerpt"><p>1.Linux磁盘分区的步骤？<br>答：第一步分区，第二步写入文件系统格式化，第三步给硬盘与分区起名，第四步挂载。</p>
<p>2.Linux文件系统格式特点？<br>答：从物理存储看&#x2F;,boot,hoom,都是地位相同的分区，但是从物理上看’&#x2F;‘是最底层的分区，boot与hoom都是’&#x2F;‘的子目录。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/28/Linux-1/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-28T17:02:20+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/28/day-9/">day 9</a><div class="content excerpt"><p>1.声明重载函数的规则？<br>答：以重载关系运算符为例，判断：对象1&#x3D;&#x3D;对象2，此时使用成员函数重载会看作对象1在调用对象2。故可以写void  operator&#x3D;&#x3D;(类名  &amp;对象2).</p>
<p>2.什么是仿函数？<br>答：重载().</p>
<p>3.子类与继承的父类成员重名会怎么样？<br>答：同名子类成员会隐藏父类成员，同名子类成员函数会隐藏所有（重载）父类同名成员函数。</p>
<p>4.什么是菱形继承问题，要怎么解决？<br>答：继承图是一个菱形，进而导致孙子类继承了两份爷爷类的数据，而不知道使用哪个的问题。使用虚继承的方式，用virtual关键字修饰爷爷类，称为虚基类。从而使孙子所继承的成员的值是两个父亲两次赋值中的最后一次的数据。<br>注意：虚继承底层是把两个父亲继承的成员变量修改为指针，指向了虚基类的成员变量（爷爷的成员变量）。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/28/day-9/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-28T09:08:34+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/27/day-8/">day 8</a><div class="content excerpt"><p>1.this指针如何解决命名冲突的问题？<br>答：由于命名不规范导致成员函数内的参数名与类内成员名相同，进而调用成员函数给类内成员赋值时导致命名冲突，此时可使用this指针指向成员。this指向的永远是调用成员函数的对象。</p>
<p>2.如何理解返回this*时要求函数返回类型是[类名&amp;]而不是[类名]？<br>答：最关键的是如果返回类名，那么会调用默认拷贝构造函数创建一个新的对象，新对象内成员的值就是原对象的值！而返回值为类&amp;时相当于：类名&amp;  (被返回的)变量名&#x3D;*this（类名  &amp;变量名&#x3D;*this），返回的就是原对象本身。</p>
<p>3.阐述空指针有时可以调用成员函数有时却不能的原因。<br>答：空指针能调用的成员函数大都是共有的与静态成员变量类似，不属于某一个对象，所以谁都可以调用。而当空指针调用的函数使用到了成员变量时，这个成员变量是对象特有的，便不能访问。</p>
<p>4.怎么重载左移运算符？<br>答：在c++中只能使用全局函数重载cout&#x2F;cin，否则必须修改标准输入输出的类。右移运算符重载是要重载cout，cout是ostream类型，且cout在c++中唯一，所以使用operator时要加引用。又因为cout属于链式函数，想要链式使用必须有返回值且返回值是cout。<br>eg: ostream &amp; operator&lt;&lt;(ostream &amp;cout,类名 &amp;某对象)；(&amp;cout必须在&amp;某对象前面才能做出[cout&lt;&lt; 某对象],否则这俩位置相反，这也是无法使用成员函数重载的原因)。<br>注意：重载函数中第一个参数只是cout的别名，也可以写成out。</p>
<p>5.重载++运算符时如何区分前置与后置？<br>答：靠参数区分，前置++无参，后置++有int占位参数。由于后置++函数体实现依靠：先记录“类名 tmp&#x3D;*this”,再加1，最后返回tmp(是局部变量!)，并不是本身因为本身已经+1了，不是后置++要的结果。所以返回值类型不加引用。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/27/day-8/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-27T08:52:49+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/26/day-7/">day 7</a><div class="content excerpt"><p>1.拷贝构造函数的第二种调用时机？<br>答：利用函数的值传递方式，这样操作会拷贝一份传入的对象，此时调用了拷贝构造函数。</p>
<p>2.拷贝构造函数的第三种调用时机？<br>答：利用函数返回值（为对象）返回局部变量的时候会调用拷贝构造，因为局部变量随着函数结束而销毁，但是返回值要求是对象，故只能拷贝生成新对象返回。</p>
<p>3.浅拷贝的定义以及带来的问题？<br>答：浅拷贝就是编译器提供的默认拷贝，由于栈的特性“先进后出”，一旦函数体内包含两个对象且对象里包含堆区指针，在调用析构函数时（包含delete）就会出现堆区内存重复释放的问题。</p>
<p>4.如何解决深拷贝带来的问题？<br>答：自己写构造函数，用new新建堆区内存代替原来直接赋值的操作。</p>
<p>5.本类中有其它类的对象时，时先构造哪个类，先析构哪个类？<br>答：先构造其他类的对象，在构造本身。析构恰恰相反，先析构本身。</p>
<p>6.如何理解静态成员变量中的“类内声明，类外初始化”？<br>答：声明就是定义个变量的意思，没有赋值操作，在类定义的外面才有初始化也就是赋值的操作。</p>
<p>7.由于静态成员变量是所有对象共有的所以除了用对象进行访问还可以怎么访问？<br>答：还可以用：“类名：：静态成员变量”，的方式访问。</p>
<p>8.为什么静态成员函数只能访问静态成员变量？<br>答：因为在类定义中的非静态成员变量不知道是哪个对象调用的。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/26/day-7/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-26T09:18:51+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/25/day-6/">day 6</a><div class="content excerpt"><p>1.类与结构体的区别？<br>答：比较或者赋值结构体可以直接用两个结构体比较或赋值、而对于类，比较类是否相等需要单独比较其中的成员函数。</p>
<p>2.vs中如何使用头文件和源文件化简程序？<br>答：参考【黑马程序员匠心之作|C++教程从0到1入门编程】第105节。</p>
<p>3.默认构造函数（无参构造）调用的时候不要加()，加了会被编译器误以为是函数的声明，不会被编译器认为是创建对象。</p>
<p>4.匿名对象如何创建以及他的特点？<br>答：特点一：直接使用构造函数不给对象起名：”类名（10）；&#x2F;&#x2F;这是有参构造函数。“由于匿名对象没有名字，所以本行执行完就结束-&gt;会引发调用析构函数的操作。<br>      特点二：不能用拷贝构造函数初始化匿名对象。否则会被认为是堆被拷贝对象的二次声明。</p>
<p>5.无参构造函数的匿名对象怎么写？<br>答：类名（）</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/25/day-6/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-25T11:14:59+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/23/day-5/">day 5</a><div class="content excerpt"><p>1.内存一共有几个区？<br>答：四个：代码区与全局区在程序运行之前就存在，栈区与堆区在程序运行后生成。</p>
<p>2.static与const修饰的区别？<br>答：static修饰的是静态变量放在全局区，而const修饰的是常量（其他常量），二者都在全局区。但是静态变量也是变量，也是可变的，只不过不随函数的开始和结束而创建和消亡。</p>
<p>3.如何利用new？<br>答：创建变量 int *p &#x3D;new int(10); delete p;     &#x2F;&#x2F;使用（）表示创建变量且值为10。<br>   ：创建数组 int *arr &#x3D;new int[10]; delete[] arr;  &#x2F;&#x2F;使用[]表示创建长度位10的数组。</p>
<p>4.引用的本质？<br>答：引用：int &amp;b &#x3D;a;给a取别名b，操作b等于操作a。本质就是指针常量 int * const b &#x3D;&amp;a ;b的指向不能改，但内容可以改</p>
<p>5.引用传递？<br>答：swap(a,b)-&gt;&gt;void swap(&amp;a,&amp;b);&#x2F;&#x2F;相当于形参中的a为实参a的别名。</p>
<p>6.函数的返回值可以是引用：使用int&amp;修饰函数。此时该函数可以作为左值，但是局部变量不可以被引用返回。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/23/day-5/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-23T09:30:22+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/22/dat-4/">dat 4</a><div class="content excerpt"><p>1.Linux下的清屏操作？<br>答：system(“reset”); 需要包含头文件<stdlib></p>
<p>2.如何比较字符串？（char<em>）<br>答：用函数int  strcmp(const char</em> s1,const char * s2),字符串相等返回0，否则大于返回1，小于返回-1，需要包含头文件<string></p>
<p>3.如何比较字符串？（string）<br>答：string是c++中的类型，可以直接使用&#x3D;&#x3D;进行比较！！！</p>
<p>4.swicth语句中，若case代码过长，需要加{}。</p>
<p>5.在Linux中如果自定义函数名为黄色说明与库中函数重名。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/22/dat-4/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-22T09:39:06+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/15/day-3/">day 3</a><div class="content excerpt"><p>1.const与static的区别？<br>答：const定义的常量在超出作用域后会释放，而static定义的常量不会在函数运行完后被释放。</p>
<p>2.如何生成随机数？<br>答：int random &#x3D;rand（）%100 ； 这样会生成0-99的假随机数。</p>
<p>3.如何生成真随机数？<br>答：还是使用上面的语句，但是在main函数里加srand((unsigned int)time(NULL))；并包含<ctime>的头文件。</p>
<p>4.为什么用string定义的字符串cout时出警告？<br>答：因为没有包含头文件<string></p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/15/day-3/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-15T13:04:51+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/10/day-2/">day 2</a><div class="content excerpt"><p>今天把前几天零零碎碎的知识点整理一下</p>
<ol>
<li><p>fopen函数返回一个FILE*结构体指针，那么该指针指向什么区域？<br>答：存放在堆区。<br>因为结构体中的变量是局部变量存放在栈中，那么当函数调用结束返回时，那个指针指向的空间已经被释放，所以不是栈。<br>也不能是静态区，因为用static修饰的时候，一个变量只会被声明一次，那么在整个函数中你只能调用一次fopen，否则打开第二个文件第一个就会失效。<br>因为堆内的空间又malloc申请，由free释放所以是最佳选择。<br>小窍门：如果返回指针的函数有互逆操作（fclose与fopen），那么返回指针大概率指向堆区。</p>
</li>
<li><p>int * p&#x3D;(int * )mallloc(sizeof(int))<br>这种强制类型转换不是在解决问题，为实在掩盖问题。不强转报错的原因是没有引用&lt;stdlib.h&gt;的头文件。</p>
</li>
<li><p>linux中查看errno含义的路径<br>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p>
</li>
</ol>
<p>4.一共有三种类型的报错方式<br>打印errno&#x3D;%d;  perror(“某函数”)； 打印sterror(errno);</p>
<p>5.const修饰指针<br>const int * p &#x3D;&amp;a ：const修饰* p ，* p不可变（内容不可变）<br>int * const p &#x3D;&amp;a ：const修饰p，p不可变（p中地址不可变）</p>
<p>6.指针变量与变量指针<br>指针变量是个变量<br>变量指针是个指针，指针就是内存地址<br>p&#x3D;&amp;a ； 左边是指针变量，右边是指针</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/10/day-2/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-10T14:14:23+08:00</span></div></div></section><section class="article"><a class="title" href="/2023/02/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">我的第一篇文章</a><div class="content excerpt"><p>今天学习了使用node，git与hexo，整理了今后一定会用到的四个指令：<br>1.hexo c 清理<br>2.hexo g 生成<br>3.hexo s 演示 （按住ctrl+左键可直接跳转到网址）<br>4.hexo d 部署到github<br>修改主题和上传博客都在这四个指令之前。</p>
</div><div class="tags"></div><div class="article-footer"><a class="excerpt-link" href="/2023/02/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">全文...</a><div class="article-footer__right"><span class="date">写于2023-02-09T18:18:23+08:00</span></div></div></section></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script></body></html>